// clang-format off
#pragma comment(lib, "Ws2_32.lib")

#include <winsock2.h>
#include <exception>
#include <iostream>
#include <mswsock.h>

#include <ws2tcpip.h>

#include "../../utils/Logger.h"
#include "../NetworkManager.h"

// clang-format on

NetworkManager::NetworkManager(int port, std::string ip_address)
{

    m_ip_address = ip_address;
    m_port = port;
    m_server_socket = NULL;
    m_server_address.sin_family = AF_INET;
    m_server_address.sin_port = htons(m_port);
    m_accept_ctx = nullptr;
    AUTOGENERATED_ID = 1;

    if (m_ip_address == ANY_IP)
    {
        m_server_address.sin_addr.s_addr = INADDR_ANY;
    }
    else
    {
        InetPton(AF_INET, m_ip_address.c_str(), &m_server_address.sin_addr);
    }
}

std::string NetworkManager::getIp() const
{
    return m_ip_address;
}

int NetworkManager::getPort() const
{
    return m_port;
}

Client *NetworkManager::addClient(uint64_t id, int port, std::string ipAddress, SOCKET sock)
{
    std::lock_guard<std::mutex> lock(m_mtx);

    std::unique_ptr client = std::make_unique<Client>(id, port, ipAddress, sock);

    m_client_list.insert({client->getId(), std::move(client)});

    return m_client_list.at(id).get();
}

void NetworkManager::setupSocket()
{
    WSADATA wsaData;

    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
    {
        throw std::runtime_error("WSAStartup failed!");
    }

    m_server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (m_server_socket == INVALID_SOCKET)
    {
        WSACleanup();
        throw std::runtime_error("Error when creating socket! (ip: " + m_ip_address +
                                 ", port: " + std::to_string(m_port));
    }

    int bindResult = bind(m_server_socket, (struct sockaddr *)&m_server_address, sizeof(m_server_address));
    if (bindResult < 0)
    {
        closeSocket();
        throw std::runtime_error("Binding socket failed! (ip: " + m_ip_address + ", port: " + std::to_string(m_port) +
                                 ")");
    }

    u_long mode = 1;
    if (ioctlsocket(m_server_socket, FIONBIO, &mode) != 0)
    {
        closeSocket();
        throw std::runtime_error("Failed to set non-blocking mode!");
    }
}

void NetworkManager::closeSocket()
{
    closesocket(m_server_socket);
    WSACleanup();
}

void NetworkManager::startListening(const std::function<void(Client &, char *)> &callback, bool async)
{
    if (m_listening)
    {
        return;
    }

    Logger &logger = Logger::getInstance();

    if (listen(m_server_socket, MAX_CONNECTION_QUEUE) == SOCKET_ERROR)
    {
        throw std::runtime_error("Error trying to listen the socket! (ip: " + m_ip_address +
                                 ", port: " + std::to_string(m_port));
    }

    HANDLE iocp = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);

    if (iocp == NULL)
    {
        throw std::runtime_error("Failed to create IOCP");
    }

    // We setup the acceptx routine so the accept and receive loop runs in another thread:
    // First we need to get the pointer to acceptEX function from winsock:
    LPFN_ACCEPTEX lpfn_AcceptEx = nullptr;
    GUID guid_AcceptEx = WSAID_ACCEPTEX;
    DWORD bytes;

    int result = WSAIoctl(m_server_socket, SIO_GET_EXTENSION_FUNCTION_POINTER, &guid_AcceptEx, sizeof(guid_AcceptEx),
                          &lpfn_AcceptEx, sizeof(lpfn_AcceptEx), &bytes, NULL, NULL);
    if (result == SOCKET_ERROR)
    {

        closeSocket();
        throw new std::runtime_error("WSAIoctl failed with error: " + std::to_string(WSAGetLastError()));
    }

    // We create the client socket, which will be set with the incoming connections
    SOCKET client_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (client_socket == INVALID_SOCKET)
    {
        closeSocket();
        throw new std::runtime_error("Creation of accept socket failed with " + std::to_string(WSAGetLastError()));
    }

    m_accept_ctx = new AcceptContext();
    m_accept_ctx->client_socket = client_socket;

    ZeroMemory(&m_accept_ctx->overlapped, sizeof(m_accept_ctx->overlapped));

    DWORD bytesAccept = 0;

    BOOL acceptEx_result =
        lpfn_AcceptEx(m_server_socket, client_socket, m_accept_ctx->rcv_buffer, 0, sizeof(m_server_address) + 16,
                      sizeof(m_server_address) + 16, &bytesAccept, &m_accept_ctx->overlapped);

    if (acceptEx_result == FALSE)
    {
        int err = WSAGetLastError();

        if (err != ERROR_IO_PENDING)
        {

            closesocket(client_socket);
            closeSocket();
            throw new std::runtime_error("Error executing first acceptEX" + std::to_string(WSAGetLastError()));
        }
    }

    m_listening = true;

    CreateIoCompletionPort((HANDLE)client_socket, iocp, (ULONG_PTR)m_accept_ctx, 0);

    // The following thread loop will be called when some socket receives data
    m_listener_thread = std::thread([this, iocp, lpfn_AcceptEx, &callback]() {
        DWORD bytes;
        ULONG_PTR completionKey;
        OVERLAPPED *overlapped;

        while (m_listening)
        {
            BOOL ok = GetQueuedCompletionStatus(iocp, &bytes, &completionKey, &overlapped, INFINITE);

            if (&m_accept_ctx->overlapped == overlapped)
            {

                // We get the ip and port:
                sockaddr *local_addr = nullptr;
                sockaddr *remote_addr = nullptr;
                int local_len = 0;
                int remote_len = 0;

                GetAcceptExSockaddrs(m_accept_ctx->rcv_buffer, 0, sizeof(SOCKADDR_IN) + 16, sizeof(SOCKADDR) + 16,
                                     (SOCKADDR **)&local_addr, &local_len, (SOCKADDR **)&remote_addr, &remote_len);

                char client_ip[INET_ADDRSTRLEN];
                DWORD client_port;

                sockaddr_in *remote_in = (sockaddr_in *)remote_addr;
                inet_ntop(AF_INET, &(remote_in->sin_addr), client_ip, INET_ADDRSTRLEN);
                client_port = ntohs(remote_in->sin_port);

                Client *client =
                    addClient(AUTOGENERATED_ID.load(), client_port, client_ip, m_accept_ctx->client_socket);

                AUTOGENERATED_ID.fetch_add(1);

                // Keep listening
                DWORD bytesAccept = 0;
                SOCKET client_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                ZeroMemory(&m_accept_ctx->overlapped, sizeof(m_accept_ctx->overlapped));

                BOOL acceptEx_result = lpfn_AcceptEx(m_server_socket, client_socket, m_accept_ctx->rcv_buffer, 0,
                                                     sizeof(m_server_address) + 16, sizeof(m_server_address) + 16,
                                                     &bytesAccept, &m_accept_ctx->overlapped);
            }
            else
            {
            }

            // callback(conn, conn->recv_buffer);
        }
    });

    m_listener_thread.detach();
}
